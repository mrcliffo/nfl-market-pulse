<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=1920, height=1080">
  <title>NFL Market Pulse - Live Prediction Markets</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --orange: #ff6b2b;
      --orange-glow: rgba(255, 107, 43, 0.3);
      --blue: #00b4ff;
      --blue-glow: rgba(0, 180, 255, 0.3);
      --dark-bg: #0a0a0f;
      --card-bg: #12121a;
      --card-border: #1e1e2a;
      --text-primary: #ffffff;
      --text-secondary: #8a8a9a;
      --green: #00d68f;
      --red: #ff4757;
    }

    body {
      width: 1920px;
      height: 1080px;
      background: var(--dark-bg);
      color: var(--text-primary);
      font-family: 'Roboto', sans-serif;
      overflow: hidden;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    /* Grid background */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
      background-size: 40px 40px;
      pointer-events: none;
      z-index: 0;
    }

    /* Glow effects */
    .glow-orange {
      box-shadow: 0 0 20px var(--orange-glow), 0 0 40px var(--orange-glow);
    }

    .glow-blue {
      box-shadow: 0 0 20px var(--blue-glow), 0 0 40px var(--blue-glow);
    }

    /* Header */
    .header {
      height: 80px;
      flex-shrink: 0;
      background: linear-gradient(180deg, rgba(18,18,26,0.98) 0%, rgba(18,18,26,0.95) 100%);
      border-bottom: 1px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 40px;
      position: relative;
      z-index: 10;
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .logo {
      font-family: 'Oswald', sans-serif;
      font-size: 32px;
      font-weight: 700;
      letter-spacing: 2px;
      background: linear-gradient(135deg, var(--orange) 0%, #ff9500 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .logo-subtitle {
      font-size: 14px;
      color: var(--text-secondary);
      letter-spacing: 3px;
      text-transform: uppercase;
    }

    .live-badge {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 71, 87, 0.15);
      border: 1px solid var(--red);
      padding: 8px 16px;
      border-radius: 4px;
      animation: pulse-live 2s ease-in-out infinite;
    }

    .live-dot {
      width: 10px;
      height: 10px;
      background: var(--red);
      border-radius: 50%;
      animation: blink 1s ease-in-out infinite;
    }

    .live-text {
      font-family: 'Oswald', sans-serif;
      font-size: 18px;
      font-weight: 600;
      color: var(--red);
      letter-spacing: 2px;
    }

    @keyframes pulse-live {
      0%, 100% { box-shadow: 0 0 10px rgba(255, 71, 87, 0.3); }
      50% { box-shadow: 0 0 20px rgba(255, 71, 87, 0.5); }
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .countdown-section {
      text-align: right;
    }

    .countdown-label {
      font-size: 12px;
      color: var(--text-secondary);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .countdown-value {
      font-family: 'Oswald', sans-serif;
      font-size: 28px;
      font-weight: 600;
      color: var(--blue);
      letter-spacing: 1px;
    }

    /* Main content */
    .main-content {
      display: flex;
      flex: 1;
      padding: 15px 40px;
      gap: 30px;
      position: relative;
      z-index: 1;
      overflow: hidden;
    }

    /* Hero market */
    .hero-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .hero-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 25px;
      display: flex;
      flex-direction: column;
    }

    /* Secondary markets grid */
    .secondary-markets {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-top: 20px;
    }

    .secondary-market-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 10px;
      padding: 15px;
    }

    .secondary-market-question {
      font-family: 'Oswald', sans-serif;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 10px;
      line-height: 1.3;
      height: 50px;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
    }

    .secondary-market-price {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .secondary-market-value {
      font-family: 'Oswald', sans-serif;
      font-size: 24px;
      font-weight: 600;
      color: var(--blue);
    }

    .secondary-market-change {
      font-size: 14px;
      font-weight: 500;
    }

    .secondary-market-volume {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 8px;
    }

    .secondary-market-card.grouped {
      display: flex;
      flex-direction: column;
    }

    .secondary-market-category {
      font-family: 'Oswald', sans-serif;
      font-size: 16px;
      font-weight: 600;
      color: var(--orange);
      margin-bottom: 12px;
      line-height: 1.2;
    }

    .secondary-market-outcomes {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1;
    }

    .outcome-row-mini {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .outcome-row-mini:last-child {
      border-bottom: none;
    }

    .outcome-name-mini {
      font-size: 13px;
      color: var(--text-primary);
    }

    .outcome-price-mini {
      font-family: 'Oswald', sans-serif;
      font-size: 15px;
      font-weight: 600;
      color: var(--blue);
    }

    /* Editorial Card */
    .editorial-card {
      background: linear-gradient(135deg, var(--card-bg) 0%, rgba(30, 30, 45, 1) 100%);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 30px 40px;
      margin-top: 15px;
      display: flex;
      gap: 50px;
      align-items: center;
      position: relative;
      overflow: hidden;
      flex: 1;
      min-height: 180px;
    }

    .editorial-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--orange) 0%, var(--blue) 100%);
    }

    .editorial-left {
      flex: 1.3;
      min-width: 0;
    }

    .editorial-right {
      flex: 1.2;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding-left: 50px;
      border-left: 1px solid var(--card-border);
    }

    .editorial-label {
      font-family: 'Oswald', sans-serif;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: var(--orange);
      margin-bottom: 10px;
    }

    .editorial-label.mover { color: var(--orange); }
    .editorial-label.debate { color: #a29bfe; }
    .editorial-label.gap { color: var(--blue); }
    .editorial-label.win { color: var(--green); }
    .editorial-label.longshot { color: #f1c40f; }
    .editorial-label.favorite { color: #e056fd; }
    .editorial-label.volume { color: #00cec9; }
    .editorial-label.fading { color: var(--red); }
    .editorial-label.engaged { color: #fd79a8; }

    .editorial-title {
      font-family: 'Oswald', sans-serif;
      font-size: 34px;
      font-weight: 600;
      line-height: 1.2;
      margin-bottom: 20px;
    }

    .editorial-stats {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .editorial-stat-primary {
      font-family: 'Oswald', sans-serif;
      font-size: 32px;
      font-weight: 600;
      white-space: nowrap;
    }

    .editorial-stat-primary.positive { color: var(--green); }
    .editorial-stat-primary.negative { color: var(--red); }
    .editorial-stat-primary.neutral { color: var(--blue); }

    .editorial-stat-bar {
      flex: 1;
      height: 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      overflow: hidden;
      min-width: 250px;
      max-width: 450px;
    }

    .editorial-bar-fill {
      height: 100%;
      border-radius: 5px;
      transition: width 0.5s ease;
      background: linear-gradient(90deg, var(--orange) 0%, var(--blue) 100%);
    }

    .editorial-bar-fill.green {
      background: linear-gradient(90deg, var(--green) 0%, #00e6a0 100%);
    }

    .editorial-bar-fill.red {
      background: linear-gradient(90deg, var(--red) 0%, #ff6b7a 100%);
    }

    /* Dynamic split bar - width controlled by CSS variable */
    .editorial-stat-bar.split-bar {
      position: relative;
      background: var(--red);
    }

    .editorial-stat-bar.split-bar .editorial-bar-fill {
      background: var(--green);
    }

    .editorial-stat-secondary {
      font-family: 'Oswald', sans-serif;
      font-size: 24px;
      font-weight: 500;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .editorial-copy {
      font-size: 22px;
      font-style: italic;
      color: var(--text-primary);
      line-height: 1.5;
      margin-bottom: 20px;
    }

    .editorial-meta {
      font-size: 16px;
      color: var(--text-secondary);
    }

    .editorial-card.fade-out {
      animation: editorialFadeOut 0.3s ease forwards;
    }

    .editorial-card.fade-in {
      animation: editorialFadeIn 0.3s ease forwards;
    }

    @keyframes editorialFadeOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-10px); }
    }

    @keyframes editorialFadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hero-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 20px;
    }

    .hero-market-label {
      font-size: 12px;
      color: var(--orange);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .hero-question {
      font-family: 'Oswald', sans-serif;
      font-size: 36px;
      font-weight: 600;
      line-height: 1.2;
      max-width: 950px;
    }

    .hero-volume {
      text-align: right;
    }

    .hero-volume-label {
      font-size: 11px;
      color: var(--text-secondary);
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .hero-volume-value {
      font-family: 'Oswald', sans-serif;
      font-size: 24px;
      font-weight: 500;
      color: var(--green);
    }

    .hero-outcomes {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 20px;
    }

    .outcome-row {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .outcome-name {
      width: 140px;
      font-size: 16px;
      font-weight: 500;
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .outcome-bar-container {
      flex: 1;
      height: 32px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .outcome-bar {
      height: 100%;
      border-radius: 4px;
      transition: width 0.8s ease-out;
      position: relative;
    }

    .outcome-bar.primary {
      background: linear-gradient(90deg, var(--orange) 0%, #ff9500 100%);
    }

    .outcome-bar.secondary {
      background: linear-gradient(90deg, var(--blue) 0%, #00d4ff 100%);
    }

    .outcome-bar.tertiary {
      background: linear-gradient(90deg, #6c5ce7 0%, #a29bfe 100%);
    }

    .outcome-bar.quaternary {
      background: linear-gradient(90deg, var(--green) 0%, #00e6a0 100%);
    }

    .outcome-price {
      width: 70px;
      font-family: 'Oswald', sans-serif;
      font-size: 20px;
      font-weight: 600;
    }

    .outcome-change {
      width: 80px;
      font-size: 14px;
      font-weight: 500;
    }

    .outcome-change.positive { color: var(--green); }
    .outcome-change.negative { color: var(--red); }
    .outcome-change.neutral { color: var(--text-secondary); }

    /* Sparkline */
    .sparkline-section {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid var(--card-border);
    }

    .sparkline-label {
      font-size: 11px;
      color: var(--text-secondary);
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .sparkline-container {
      height: 60px;
      display: flex;
      align-items: flex-end;
      gap: 3px;
    }

    .sparkline-bar {
      flex: 1;
      background: linear-gradient(180deg, var(--blue) 0%, rgba(0, 180, 255, 0.3) 100%);
      border-radius: 2px 2px 0 0;
      transition: height 0.3s ease;
    }

    /* Sidebar */
    .sidebar {
      width: 420px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .sidebar-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 20px;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }

    .sidebar-icon {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .sidebar-icon.orange { background: var(--orange); }
    .sidebar-icon.blue { background: var(--blue); }

    .sidebar-title {
      font-family: 'Oswald', sans-serif;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    /* Movers */
    .movers-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .mover-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 14px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), background 0.2s, opacity 0.3s;
    }

    .mover-item.moving-up {
      animation: moveUpGlow 0.6s ease;
    }

    .mover-item.moving-down {
      animation: moveDownFade 0.6s ease;
    }

    @keyframes moveUpGlow {
      0% { background: rgba(0, 212, 170, 0.1); }
      100% { background: rgba(255, 255, 255, 0.02); }
    }

    @keyframes moveDownFade {
      0% { background: rgba(255, 107, 107, 0.1); }
      100% { background: rgba(255, 255, 255, 0.02); }
    }

    .mover-rank {
      font-family: 'Oswald', sans-serif;
      font-size: 18px;
      font-weight: 600;
      color: var(--text-secondary);
      width: 24px;
      flex-shrink: 0;
      padding-top: 2px;
    }

    .mover-info {
      flex: 1;
      min-width: 0;
    }

    .mover-market {
      font-size: 15px;
      font-weight: 500;
      line-height: 1.3;
      margin-bottom: 4px;
    }

    .mover-change {
      font-family: 'Oswald', sans-serif;
      font-size: 20px;
      font-weight: 600;
      flex-shrink: 0;
      padding-top: 2px;
    }

    .mover-change.positive { color: var(--green); }
    .mover-change.negative { color: var(--red); }

    /* Vote section */
    .vote-card {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .qr-container {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 15px;
      background: white;
      border-radius: 12px;
      margin-bottom: 12px;
    }

    #qrcode {
      width: 160px;
      height: 160px;
    }

    #qrcode canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .vote-cta {
      text-align: center;
      margin-bottom: 10px;
    }

    .vote-cta-text {
      font-family: 'Oswald', sans-serif;
      font-size: 20px;
      font-weight: 600;
      color: var(--orange);
      letter-spacing: 1px;
    }

    .vote-cta-sub {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    .vote-window {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: rgba(0, 180, 255, 0.1);
      border: 1px solid rgba(0, 180, 255, 0.3);
      border-radius: 8px;
      margin-bottom: 16px;
    }

    .vote-window-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .vote-window-time {
      font-family: 'Oswald', sans-serif;
      font-size: 20px;
      font-weight: 600;
      color: var(--blue);
    }

    .vote-stats {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: auto;
    }

    .vote-stat {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }

    .vote-stat-label {
      color: var(--text-secondary);
    }

    .vote-stat-value {
      font-weight: 500;
    }

    /* Ticker */
    .ticker {
      height: 80px;
      min-height: 80px;
      flex-shrink: 0;
      background: linear-gradient(180deg, var(--card-bg) 0%, rgba(18,18,26,0.98) 100%);
      display: flex;
      align-items: center;
      overflow: hidden;
      position: relative;
      z-index: 10;
    }

    .ticker-label {
      background: var(--orange);
      color: white;
      font-family: 'Oswald', sans-serif;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 2px;
      padding: 10px 20px;
      white-space: nowrap;
      z-index: 2;
      position: relative;
      align-self: stretch;
      display: flex;
      align-items: center;
    }

    .ticker-label::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: calc(100vw - 100%);
      height: 2px;
      background: var(--orange);
    }

    .ticker-content {
      display: flex;
      animation: ticker-scroll 60s linear infinite;
    }

    .ticker-item {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 0 40px;
      white-space: nowrap;
    }

    .ticker-name {
      font-size: 20px;
      font-weight: 500;
    }

    .ticker-price {
      font-family: 'Oswald', sans-serif;
      font-size: 24px;
      font-weight: 600;
      color: var(--blue);
    }

    .ticker-change {
      font-size: 18px;
      font-weight: 500;
    }

    .ticker-change.positive { color: var(--green); }
    .ticker-change.negative { color: var(--red); }

    .ticker-event-title {
      color: var(--orange);
      font-weight: 600;
      margin-right: 8px;
    }

    .ticker-outcomes {
      font-size: 18px;
      color: var(--text-primary);
    }

    .ticker-divider {
      color: var(--card-border);
      font-size: 20px;
    }

    @keyframes ticker-scroll {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    /* Loading state */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-secondary);
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--card-border);
      border-top-color: var(--orange);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Data update flash */
    .data-updated {
      animation: flash-update 0.5s ease;
    }

    @keyframes flash-update {
      0% { background-color: rgba(0, 180, 255, 0.2); }
      100% { background-color: transparent; }
    }

    /* Price change animations */
    .price-up {
      animation: flash-green 1.5s ease;
    }

    .price-down {
      animation: flash-red 1.5s ease;
    }

    @keyframes flash-green {
      0% { background-color: rgba(0, 214, 143, 0.4); }
      100% { background-color: transparent; }
    }

    @keyframes flash-red {
      0% { background-color: rgba(255, 71, 87, 0.4); }
      100% { background-color: transparent; }
    }

    /* Value highlight */
    .value-changed {
      animation: highlight-pulse 2s ease;
    }

    @keyframes highlight-pulse {
      0% { color: var(--orange); text-shadow: 0 0 10px var(--orange); }
      50% { color: var(--orange); text-shadow: 0 0 20px var(--orange); }
      100% { text-shadow: none; }
    }

    /* Card glow effect */
    .card-glow-up {
      animation: glow-green 2s ease;
    }

    .card-glow-down {
      animation: glow-red 2s ease;
    }

    @keyframes glow-green {
      0% { box-shadow: 0 0 20px rgba(0, 214, 143, 0.6), 0 0 40px rgba(0, 214, 143, 0.3); }
      100% { box-shadow: none; }
    }

    @keyframes glow-red {
      0% { box-shadow: 0 0 20px rgba(255, 71, 87, 0.6), 0 0 40px rgba(255, 71, 87, 0.3); }
      100% { box-shadow: none; }
    }

    /* Animated arrows */
    .change-arrow {
      display: inline-block;
      margin-left: 6px;
      font-size: 14px;
      animation: arrow-bounce 1s ease 3;
    }

    .change-arrow.up {
      color: var(--green);
    }

    .change-arrow.down {
      color: var(--red);
    }

    @keyframes arrow-bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }

    /* Live update indicator */
    .live-update-badge {
      position: fixed;
      top: 90px;
      right: 40px;
      background: linear-gradient(135deg, var(--green) 0%, #00e6a0 100%);
      color: var(--dark-bg);
      padding: 8px 16px;
      border-radius: 20px;
      font-family: 'Oswald', sans-serif;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 1px;
      z-index: 100;
      opacity: 0;
      transform: translateX(100px);
      transition: all 0.3s ease;
    }

    .live-update-badge.visible {
      opacity: 1;
      transform: translateX(0);
    }

    /* Error state */
    .error-badge {
      position: fixed;
      top: 100px;
      right: 40px;
      background: rgba(255, 71, 87, 0.9);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
      display: none;
    }

    .error-badge.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div class="error-badge" id="errorBadge">Using cached data - API temporarily unavailable</div>
  <div class="live-update-badge" id="liveUpdateBadge">PRICES UPDATED</div>

  <header class="header">
    <div class="logo-section">
      <div>
        <div class="logo">NFL MARKET PULSE</div>
        <div class="logo-subtitle">Powered by Polymarket</div>
      </div>
      <div class="live-badge">
        <div class="live-dot"></div>
        <span class="live-text">LIVE</span>
      </div>
    </div>
    <div class="countdown-section">
      <div class="countdown-label">Super Bowl LX</div>
      <div class="countdown-value" id="countdown">Loading...</div>
    </div>
  </header>

  <main class="main-content">
    <section class="hero-section">
      <div class="hero-card" id="heroCard">
        <div class="hero-header">
          <div>
            <div class="hero-market-label">Featured Market</div>
            <h1 class="hero-question" id="heroQuestion">Loading markets...</h1>
          </div>
          <div class="hero-volume">
            <div class="hero-volume-label">24h Volume</div>
            <div class="hero-volume-value" id="heroVolume">--</div>
          </div>
        </div>
        <div class="hero-outcomes" id="heroOutcomes">
          <div class="loading">
            <div class="loading-spinner"></div>
          </div>
        </div>
        <div class="sparkline-section">
          <div class="sparkline-label">7-Day Price Trend</div>
          <div class="sparkline-container" id="sparkline"></div>
        </div>
      </div>

      <!-- Secondary Markets Grid -->
      <div class="secondary-markets" id="secondaryMarkets">
        <!-- Populated by JS -->
      </div>

      <!-- Editorial Content Card -->
      <div class="editorial-card" id="editorialCard">
        <div class="editorial-left">
          <div class="editorial-label" id="editorialLabel">BIG MOVER</div>
          <div class="editorial-title" id="editorialTitle">Loading...</div>
          <div class="editorial-stats" id="editorialStats">
            <div class="editorial-stat-primary" id="editorialStatPrimary"></div>
            <div class="editorial-stat-bar" id="editorialStatBar">
              <div class="editorial-bar-fill" id="editorialBarFill"></div>
            </div>
            <div class="editorial-stat-secondary" id="editorialStatSecondary"></div>
          </div>
        </div>
        <div class="editorial-right">
          <div class="editorial-copy" id="editorialCopy">"The market is moving fast..."</div>
          <div class="editorial-meta" id="editorialMeta"></div>
        </div>
      </div>
    </section>

    <aside class="sidebar">
      <div class="sidebar-card">
        <div class="sidebar-header">
          <div class="sidebar-icon orange"></div>
          <h2 class="sidebar-title">24H Biggest Movers</h2>
        </div>
        <div class="movers-list" id="moversList">
          <div class="loading">
            <div class="loading-spinner"></div>
          </div>
        </div>
      </div>

      <div class="sidebar-card vote-card">
        <div class="sidebar-header">
          <div class="sidebar-icon blue"></div>
          <h2 class="sidebar-title">Vote Now</h2>
        </div>
        <div class="qr-container">
          <div id="qrcode"></div>
        </div>
        <div class="vote-cta">
          <div class="vote-cta-text">SCAN TO VOTE</div>
          <div class="vote-cta-sub">Compare your pick to the market</div>
        </div>
        <div class="vote-stats" id="voteStats">
          <div class="vote-stat">
            <span class="vote-stat-label">Total votes</span>
            <span class="vote-stat-value" id="totalVotes">0</span>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <footer class="ticker">
    <div class="ticker-label">NFL MARKETS</div>
    <div class="ticker-content" id="tickerContent">
      <!-- Populated by JS -->
    </div>
  </footer>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      // Production URLs
      voteAppUrl: 'https://nfl-market-pulse.vercel.app/vote',
      apiUrl: 'https://nfl-market-pulse.vercel.app/api',

      // Voting window duration in seconds
      windowDuration: 180,

      // Hero market rotation interval in seconds
      heroRotationInterval: 30,

      // Data refresh interval in seconds
      dataRefreshInterval: 60,

      // Super Bowl LX date
      superBowlDate: new Date('2026-02-08T18:30:00-05:00'),

      // NFL search terms
      nflTerms: [
        'nfl', 'super bowl', 'afc', 'nfc', 'playoff', 'playoffs',
        'bills', 'buffalo', 'dolphins', 'miami', 'patriots', 'new england', 'jets', 'new york jets',
        'ravens', 'baltimore', 'bengals', 'cincinnati', 'browns', 'cleveland', 'steelers', 'pittsburgh',
        'texans', 'houston', 'colts', 'indianapolis', 'jaguars', 'jacksonville', 'titans', 'tennessee',
        'chiefs', 'kansas city', 'broncos', 'denver', 'raiders', 'las vegas', 'chargers', 'los angeles chargers',
        'cowboys', 'dallas', 'giants', 'new york giants', 'eagles', 'philadelphia', 'commanders', 'washington',
        'bears', 'chicago', 'lions', 'detroit', 'packers', 'green bay', 'vikings', 'minnesota',
        'falcons', 'atlanta', 'panthers', 'carolina', 'saints', 'new orleans', 'buccaneers', 'tampa bay', 'bucs',
        '49ers', 'san francisco', 'niners', 'cardinals', 'arizona', 'rams', 'los angeles rams', 'seahawks', 'seattle'
      ]
    };

    // ============================================
    // MOCK DATA (Fallback)
    // ============================================
    const MOCK_MARKETS = [
      {
        id: 'sb-winner',
        question: 'Who will win Super Bowl LX?',
        slug: 'super-bowl-lx-winner',
        outcomes: ['Chiefs', 'Ravens', 'Lions', 'Bills', 'Eagles', '49ers', 'Packers', 'Cowboys'],
        outcomePrices: ['0.234', '0.182', '0.151', '0.128', '0.113', '0.089', '0.067', '0.036'],
        volume: 2400000,
        volume24hr: 145000,
        oneDayPriceChange: 0.021
      },
      {
        id: 'afc-champion',
        question: 'Who will win the AFC Championship?',
        slug: 'afc-championship-winner',
        outcomes: ['Chiefs', 'Ravens', 'Bills', 'Texans', 'Dolphins', 'Bengals'],
        outcomePrices: ['0.312', '0.241', '0.189', '0.121', '0.089', '0.048'],
        volume: 1800000,
        volume24hr: 98000,
        oneDayPriceChange: -0.015
      },
      {
        id: 'nfc-champion',
        question: 'Who will win the NFC Championship?',
        slug: 'nfc-championship-winner',
        outcomes: ['Lions', 'Eagles', '49ers', 'Packers', 'Cowboys', 'Rams'],
        outcomePrices: ['0.278', '0.223', '0.198', '0.156', '0.089', '0.056'],
        volume: 1650000,
        volume24hr: 87000,
        oneDayPriceChange: 0.032
      },
      {
        id: 'mvp',
        question: 'Who will win Super Bowl LX MVP?',
        slug: 'super-bowl-lx-mvp',
        outcomes: ['Patrick Mahomes', 'Lamar Jackson', 'Jared Goff', 'Josh Allen', 'Jalen Hurts'],
        outcomePrices: ['0.198', '0.167', '0.143', '0.121', '0.098'],
        volume: 890000,
        volume24hr: 45000,
        oneDayPriceChange: 0.008
      },
      {
        id: 'chiefs-wins',
        question: 'Will the Chiefs win 14+ regular season games?',
        slug: 'chiefs-14-wins',
        outcomes: ['Yes', 'No'],
        outcomePrices: ['0.67', '0.33'],
        volume: 340000,
        volume24hr: 23000,
        oneDayPriceChange: 0.045
      },
      {
        id: 'lions-sb',
        question: 'Will the Lions make their first Super Bowl?',
        slug: 'lions-first-super-bowl',
        outcomes: ['Yes', 'No'],
        outcomePrices: ['0.28', '0.72'],
        volume: 520000,
        volume24hr: 34000,
        oneDayPriceChange: -0.023
      }
    ];

    // ============================================
    // STATE
    // ============================================
    let state = {
      markets: [],
      groupedEvents: [], // Markets grouped by event ID
      previousPrices: {}, // Track prices for change detection
      heroIndex: 0,
      groupIndex: 0, // For cycling through grouped events
      editorialIndex: 0, // For cycling through editorial themes
      currentToken: generateToken(),
      windowStartTime: Date.now(),
      voteStats: { window: 0, total: 0 },
      crowdVotes: {}, // Store crowd vote percentages for sentiment gaps
      usingMockData: false
    };

    // ============================================
    // EDITORIAL CONTENT
    // ============================================
    const EDITORIAL_COPY = {
      bigMovers: [
        "The market is moving fast. When odds shift this hard, someone knows something.",
        "This isn't noise - it's a signal. Smart money is repositioning.",
        "A swing this big doesn't happen by accident. The narrative just changed.",
        "Breaking: The market just repriced everything we thought we knew.",
        "When the line moves like this, it's time to pay attention.",
        "Odds don't lie. Something just shifted the calculus.",
        "The smart money is making a statement. Are you listening?",
        "This kind of movement usually means news is about to break.",
        "A dramatic reprice. The collective wisdom just changed its mind.",
        "Follow the money. It's telling a story right now.",
        "Whiplash. The market just did a complete 180 on this one.",
        "Big money just entered the chat. Odds are moving fast.",
        "Someone's betting like they know the ending. Watch this space.",
        "The market doesn't panic for nothing. What changed?",
        "Sharp bettors are loading up. This move has conviction written all over it.",
        "When lines move this fast, insiders are usually involved.",
        "A seismic shift. Yesterday's longshot is today's contender.",
        "The algorithm detected smoke. Where there's smoke, there's fire.",
        "Momentum is everything. This market just found some.",
        "Price discovery in real time. The truth is being repriced."
      ],
      debateFuel: [
        "The market can't decide. Neither can Vegas. Pick your side.",
        "A true coin flip. This is where debates get heated.",
        "Split right down the middle. Perfect for a hot take.",
        "50/50 odds means maximum uncertainty. Time to pick a lane.",
        "The wisdom of crowds is deadlocked. What do YOU think?",
        "No consensus. No clear favorite. Just pure debate material.",
        "When the market is this divided, everyone has an opinion.",
        "Too close to call. This one's going to split the room.",
        "Neither side is backing down. The ultimate pick-a-side question.",
        "Dead heat. This is what sports arguments are made of.",
        "The ultimate sports bar debate. No clear winner in sight.",
        "Both sides think they're right. Only one will be.",
        "Maximum chaos. The prediction market is throwing up its hands.",
        "This is the kind of pick that ruins friendships. Choose wisely.",
        "Flip a coin? The market basically already did.",
        "Perfectly balanced. As all sports debates should be.",
        "The analytics say maybe. The gut says maybe. Good luck.",
        "Two fan bases. One trophy. Zero consensus.",
        "When the market shrugs, it's time for hot takes.",
        "The only certainty here is uncertainty. Make your case."
      ],
      sentimentGaps: [
        "Fan optimism is way higher than the smart money. Who's right?",
        "The market says one thing. The fans say another. Someone's wrong.",
        "A massive gap between Wall Street and Main Street. Classic.",
        "Are fans delusional, or do they see something the market doesn't?",
        "The wisdom of crowds vs. the weight of money. Fight!",
        "When fans and bettors disagree this much, that's a story.",
        "Heart says yes. Money says no. The eternal sports debate.",
        "This gap is content gold. Why does smart money disagree with fans?",
        "Passion vs. probability. The fans aren't buying what the market's selling.",
        "The market thinks fans are dreaming. Are they?",
        "The spreadsheet says no. The heart says yes. Tale as old as time.",
        "Fans see a champion. The market sees a mirage. Who blinks first?",
        "Hope vs. the house. The eternal underdog story.",
        "The analytics nerds and the superfans are at war. Pick a side.",
        "Sometimes the crowd knows. Sometimes the crowd hopes. Which is this?",
        "The market is cold. The fans are not. Temperature check: scorching.",
        "Belief is priceless. Unless you're betting on it.",
        "The fans have faith. The market has data. Classic showdown.",
        "Emotional investing meets rational markets. This won't end well for someone.",
        "The beautiful game of fans vs. forecasts. Never gets old."
      ],
      bigWins: [
        "If you staked $100 on Polymarket, you'd be counting ${payout} right now.",
        "Early believers just cashed out big. $100 became ${payout}.",
        "The market doubted it. The believers didn't. Payday: ${payout} on $100.",
        "That's a ${returnPct}% return. Not bad for trusting your gut.",
        "Conviction paid off. $100 in, ${payout} out. Who called it?",
        "The smart money was wrong. The brave money just won big.",
        "From underdog odds to winner's circle. $100 â†’ ${payout}.",
        "This is what betting on yourself looks like. ${profit} profit on $100.",
        "The doubters are quiet. The winners are cashing ${payout} per $100 staked.",
        "Against the odds, into the money. $100 became ${payout}."
      ],
      longshotWatch: [
        "The market says no way. But momentum says... maybe?",
        "At these odds, believers get paid BIG if they're right.",
        "A longshot climbing the ladder. Early believers are watching closely.",
        "The market has them written off. The trend says not so fast.",
        "Underdogs don't stay underdogs forever. This one's making noise.",
        "Low probability, high potential. The ultimate contrarian play.",
        "The market is sleeping on this one. Are you?",
        "Single-digit odds but double-digit momentum. Something's brewing.",
        "Every dynasty started as a longshot. Just saying.",
        "The payout potential here is massive. Risk vs reward at its finest.",
        "Longshots make legends. This one's trending in the right direction.",
        "The market hasn't caught on yet. Early movers get rewarded.",
        "Written off by Vegas, backed by believers. Classic underdog story.",
        "At these prices, it doesn't take much to be right.",
        "The market's doubt is your opportunity. If you're bold enough.",
        "Climbing from the basement. Longshot watch is ON.",
        "Low odds, high drama. This is what makes sports betting fun.",
        "The analytics say unlikely. The trend says hold my beer.",
        "A spark in the darkness. Longshot believers, assemble.",
        "The market priced them out. Are they pricing themselves back in?"
      ],
      crowdFavorites: [
        "The fans have spoken. And they're not being subtle about it.",
        "Near-unanimous conviction from the crowd. That's rare.",
        "When the audience agrees this strongly, it's worth noting.",
        "The people are ALL IN on this one. No hesitation.",
        "Crowd consensus is off the charts. Everyone sees the same thing.",
        "Democracy in action. The fans have made their pick crystal clear.",
        "This isn't a debate anymore. The crowd has decided.",
        "Overwhelming fan confidence. The market might want to pay attention.",
        "The voice of the people is LOUD on this one.",
        "Fan conviction at maximum. Is the market listening?",
        "The crowd sees something here. Something big.",
        "When everyone agrees, either everyone's right or everyone's wrong.",
        "Peak fan confidence. This is as decisive as it gets.",
        "The audience has chosen their champion. No close calls here.",
        "Consensus pick. The fans are speaking with one voice.",
        "Maximum crowd conviction. The debate is over.",
        "The people's choice, overwhelmingly. Time will tell if they're right.",
        "Fan favorite status: LOCKED IN.",
        "Crowd wisdom or crowd delusion? Either way, they're committed.",
        "The fans aren't hedging. They're ALL the way in."
      ],
      volumeSurge: [
        "Money is POURING in. Something's got people's attention.",
        "Volume spike detected. Big money is making moves.",
        "The betting window just got busy. Way busy.",
        "A surge of conviction. Wallets are opening wide.",
        "When volume explodes like this, pay attention.",
        "The market just woke up. Money is flooding in.",
        "Sudden interest spike. What do they know that we don't?",
        "Volume doesn't lie. Someone's loading up on this one.",
        "Cash is flowing. This market just got hot.",
        "A tidal wave of bets. The market is ON FIRE.",
        "Volume surge alert. The smart money is active.",
        "Money talks, and right now it's SCREAMING.",
        "Betting activity just spiked. Something changed.",
        "The floodgates opened. Volume is through the roof.",
        "When this much money moves, it's not random.",
        "Market activity exploding. Everyone wants a piece.",
        "The volume tells the story. And it's getting interesting.",
        "Big money energy. This market is buzzing.",
        "A rush of bets. The market can feel the momentum.",
        "Volume spike = conviction spike. The bettors are locked in."
      ],
      fadingFast: [
        "The odds are collapsing. Yesterday's favorite is today's afterthought.",
        "Fading fast. The market is losing faith quickly.",
        "A rapid decline. Something went very wrong here.",
        "From contender to pretender. The drop is brutal.",
        "The market just delivered a reality check. Ouch.",
        "Falling like a stone. What changed?",
        "The hype train derailed. Odds are in freefall.",
        "A collapse in confidence. The believers are bailing.",
        "Yesterday's darling, today's discount. The fade is real.",
        "The market just hit the sell button. Hard.",
        "Dropping fast. The narrative shifted overnight.",
        "From hero to zero probability. A harsh correction.",
        "The bubble burst. This one's fading into oblivion.",
        "Market confidence evaporating. Not a good sign.",
        "A steep decline. The smart money saw something.",
        "Freefall mode activated. The odds tell the story.",
        "The market just ghosted this pick. RIP to the believers.",
        "Crashing down. What looked promising now looks desperate.",
        "A brutal correction. The market shows no mercy.",
        "Odds melting away. Someone's thesis just got destroyed."
      ],
      mostEngaged: [
        "This market has everyone talking. And voting. A lot.",
        "Maximum engagement. The fans can't stop weighing in.",
        "The most-debated market right now. Everyone has an opinion.",
        "Fan engagement is through the roof. This one matters to people.",
        "The audience is OBSESSED with this pick. Vote after vote.",
        "High engagement = high interest. This market has both.",
        "Everyone wants their voice heard on this one.",
        "The fans won't stop voting. Peak engagement.",
        "This market is capturing hearts and minds. Engagement proves it.",
        "The people are invested. Not just money - opinions too.",
        "Fan activity is OFF THE CHARTS. What a market.",
        "Where there's smoke, there's fire. Where there's votes, there's passion.",
        "The most participatory market of the moment. Join the conversation.",
        "Engagement levels: maximum. The fans have spoken. A lot.",
        "This one has the people's attention. All of it.",
        "Vote count climbing. The fans are locked in.",
        "When engagement spikes, the market matters. This one matters.",
        "The audience can't look away. Neither should you.",
        "Peak fan participation. This is the market everyone cares about.",
        "Engagement king of the moment. The fans have crowned it."
      ]
    };

    function getRandomCopy(theme) {
      const copies = EDITORIAL_COPY[theme];
      return copies[Math.floor(Math.random() * copies.length)];
    }

    function findBigMover() {
      // Find markets with significant daily price changes (rotate through them)
      const qualifyingMarkets = state.markets.filter(market => {
        const change = Math.abs(parseFloat(market.oneDayPriceChange || 0));
        return change > 0.02; // At least 2% change
      }).sort((a, b) => {
        return Math.abs(parseFloat(b.oneDayPriceChange || 0)) - Math.abs(parseFloat(a.oneDayPriceChange || 0));
      });

      if (qualifyingMarkets.length === 0) return null;

      // Rotate through top 10 movers
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 10);
      return qualifyingMarkets[idx];
    }

    function findDebateFuel() {
      // Find markets close to 50/50 (rotate through them)
      const qualifyingMarkets = state.markets.filter(market => {
        const prices = market.outcomePrices || [];
        const yesPrice = parseFloat(prices[0] || 0);
        const distanceFrom50 = Math.abs(yesPrice - 0.5);
        return distanceFrom50 < 0.15; // Within 15% of 50/50
      }).sort((a, b) => {
        // Sort by volume descending (show higher volume markets more)
        return parseFloat(b.volume || 0) - parseFloat(a.volume || 0);
      });

      if (qualifyingMarkets.length === 0) return null;

      // Rotate through top debate markets
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 8);
      return qualifyingMarkets[idx];
    }

    function findSentimentGap() {
      // Find markets with gap between market price and crowd vote (rotate through them)
      const qualifyingMarkets = [];

      state.markets.forEach(market => {
        const prices = market.outcomePrices || [];
        const marketPrice = parseFloat(prices[0] || 0);
        // Look up crowd vote by market slug
        const crowdVote = state.crowdVotes[market.slug] || null;

        if (crowdVote !== null) {
          const gap = Math.abs(marketPrice - crowdVote);
          if (gap > 0.05) { // At least 5% gap
            qualifyingMarkets.push({ ...market, crowdVote, gap });
          }
        }
      });

      if (qualifyingMarkets.length === 0) return null;

      // Sort by gap size descending
      qualifyingMarkets.sort((a, b) => b.gap - a.gap);

      // Rotate through markets with sentiment gaps
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 8);
      return qualifyingMarkets[idx];
    }

    function findBigWin() {
      // Find recently resolved markets with big payouts
      // For now, simulate (would need to track resolved markets)
      const resolvedExamples = [
        { question: "Saquon Barkley - NFL Rushing Yards Leader", entryPrice: 0.38, result: "WON" },
        { question: "Lions to make NFC Championship", entryPrice: 0.42, result: "WON" },
        { question: "Josh Allen - NFL MVP", entryPrice: 0.28, result: "WON" },
        { question: "Lamar Jackson - 4000+ Passing Yards", entryPrice: 0.35, result: "WON" },
        { question: "Bills to win AFC East", entryPrice: 0.45, result: "WON" }
      ];

      const example = resolvedExamples[Math.floor(Math.random() * resolvedExamples.length)];
      const payout = (1 / example.entryPrice).toFixed(2);
      const profit = ((1 / example.entryPrice) - 1) * 100;
      const returnPct = (((1 / example.entryPrice) - 1) * 100).toFixed(0);

      return {
        question: example.question,
        entryPrice: example.entryPrice,
        payout: (parseFloat(payout) * 100).toFixed(0),
        profit: profit.toFixed(0),
        returnPct
      };
    }

    function findLongshotWatch() {
      // Find markets priced under 15% that are gaining momentum (positive price change)
      const qualifyingMarkets = state.markets.filter(market => {
        const prices = market.outcomePrices || [];
        const yesPrice = parseFloat(prices[0] || 0);
        const change = parseFloat(market.oneDayPriceChange || 0);
        // Low probability (under 15%) but gaining momentum (positive change)
        return yesPrice < 0.15 && yesPrice > 0.01 && change > 0.005;
      }).sort((a, b) => {
        // Sort by price change descending (biggest movers first)
        return parseFloat(b.oneDayPriceChange || 0) - parseFloat(a.oneDayPriceChange || 0);
      });

      if (qualifyingMarkets.length === 0) return null;

      // Rotate through top 8 longshots
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 8);
      return qualifyingMarkets[idx];
    }

    function findCrowdFavorite() {
      // Find markets where crowd voted decisively (90%+ YES or 90%+ NO)
      const qualifyingMarkets = [];

      state.markets.forEach(market => {
        const crowdVote = state.crowdVotes[market.slug] || null;
        if (crowdVote !== null) {
          // Check if crowd is very decisive (90%+ one way or the other)
          const conviction = Math.max(crowdVote, 1 - crowdVote);
          if (conviction >= 0.85) { // 85%+ conviction
            qualifyingMarkets.push({
              ...market,
              crowdVote,
              conviction,
              crowdSaysYes: crowdVote > 0.5
            });
          }
        }
      });

      if (qualifyingMarkets.length === 0) return null;

      // Sort by conviction level descending
      qualifyingMarkets.sort((a, b) => b.conviction - a.conviction);

      // Rotate through top crowd favorites
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 8);
      return qualifyingMarkets[idx];
    }

    function findVolumeSurge() {
      // Find markets with high 24h volume relative to total volume (recent surge)
      const qualifyingMarkets = state.markets.filter(market => {
        const volume24h = parseFloat(market.volume24hr || 0);
        const totalVolume = parseFloat(market.volume || 0);
        // 24h volume is at least 10% of total volume (indicates recent surge)
        // and has meaningful absolute volume
        return totalVolume > 0 && volume24h > 10000 && (volume24h / totalVolume) > 0.08;
      }).sort((a, b) => {
        // Sort by 24h volume descending
        return parseFloat(b.volume24hr || 0) - parseFloat(a.volume24hr || 0);
      });

      if (qualifyingMarkets.length === 0) return null;

      // Rotate through top volume markets
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 8);
      return qualifyingMarkets[idx];
    }

    function findFadingFast() {
      // Find markets with significant negative price changes (opposite of big movers)
      const qualifyingMarkets = state.markets.filter(market => {
        const change = parseFloat(market.oneDayPriceChange || 0);
        return change < -0.02; // At least 2% drop
      }).sort((a, b) => {
        // Sort by change ascending (biggest drops first)
        return parseFloat(a.oneDayPriceChange || 0) - parseFloat(b.oneDayPriceChange || 0);
      });

      if (qualifyingMarkets.length === 0) return null;

      // Rotate through top 10 faders
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 10);
      return qualifyingMarkets[idx];
    }

    function findMostEngaged() {
      // Find markets with the most votes from audience
      const qualifyingMarkets = [];

      state.markets.forEach(market => {
        const slug = market.slug;
        // Check if this market has vote data by looking for it in crowdVotes
        // We need to also track vote counts - for now, use presence in crowdVotes
        // as a proxy (markets with votes will be in crowdVotes)
        if (state.crowdVotes[slug] !== undefined) {
          qualifyingMarkets.push({
            ...market,
            crowdVote: state.crowdVotes[slug],
            hasVotes: true
          });
        }
      });

      if (qualifyingMarkets.length === 0) return null;

      // Sort by volume as a proxy for engagement (higher volume = more interest)
      qualifyingMarkets.sort((a, b) => parseFloat(b.volume || 0) - parseFloat(a.volume || 0));

      // Rotate through most engaged markets
      const idx = state.editorialIndex % Math.min(qualifyingMarkets.length, 8);
      return qualifyingMarkets[idx];
    }

    function renderEditorial() {
      const card = document.getElementById('editorialCard');
      // 8 themes total - original 3 + 5 new ones
      // Some themes require specific data to be available
      const themes = [
        'bigMovers',      // Markets with >2% daily change
        'debateFuel',     // Markets close to 50/50
        'sentimentGaps',  // Crowd vs market disagreement (needs votes)
        'longshotWatch',  // Low odds but gaining momentum
        'crowdFavorites', // Decisive crowd votes 85%+ (needs votes)
        'volumeSurge',    // High recent volume activity
        'fadingFast',     // Biggest price drops
        'mostEngaged'     // Markets with most audience votes (needs votes)
      ];

      // Try themes starting from current index, skip if no data
      let theme = null;
      let attempts = 0;
      while (!theme && attempts < themes.length) {
        const tryTheme = themes[(state.editorialIndex + attempts) % themes.length];
        // Check if this theme has data before selecting it
        if (tryTheme === 'sentimentGaps' && !findSentimentGap()) {
          attempts++;
          continue;
        }
        if (tryTheme === 'longshotWatch' && !findLongshotWatch()) {
          attempts++;
          continue;
        }
        if (tryTheme === 'crowdFavorites' && !findCrowdFavorite()) {
          attempts++;
          continue;
        }
        if (tryTheme === 'volumeSurge' && !findVolumeSurge()) {
          attempts++;
          continue;
        }
        if (tryTheme === 'fadingFast' && !findFadingFast()) {
          attempts++;
          continue;
        }
        if (tryTheme === 'mostEngaged' && !findMostEngaged()) {
          attempts++;
          continue;
        }
        theme = tryTheme;
      }

      // If no theme has data, default to bigMovers
      if (!theme) theme = 'bigMovers';

      // Fade out
      card.classList.add('fade-out');

      setTimeout(() => {
        let content = null;

        // Helper to get full market title with event context
        function getFullMarketTitle(market) {
          const eventTitle = market.events?.[0]?.title || '';
          const outcomeName = market.groupItemTitle || '';

          // If we have both event and outcome, combine them
          if (eventTitle && outcomeName && !market.question.includes(eventTitle)) {
            return `${eventTitle}: ${outcomeName}`;
          }
          // Otherwise use the full question
          return market.question;
        }

        switch (theme) {
          case 'bigMovers':
            const mover = findBigMover();
            if (mover) {
              const change = parseFloat(mover.oneDayPriceChange || 0);
              const prices = mover.outcomePrices || [];
              const currentPrice = parseFloat(prices[0] || 0);
              const previousPrice = currentPrice - change;

              content = {
                label: 'BIG MOVER',
                labelClass: 'mover',
                title: getFullMarketTitle(mover),
                statPrimary: `${(previousPrice * 100).toFixed(1)}% â†’ ${(currentPrice * 100).toFixed(1)}%`,
                statPrimaryClass: change > 0 ? 'positive' : 'negative',
                barWidthStart: Math.max(0, previousPrice * 100),
                barWidth: currentPrice * 100,
                barClass: change > 0 ? 'green' : 'red',
                barContainerClass: '',
                animateBar: true,
                statSecondary: `(${change > 0 ? '+' : ''}${(change * 100).toFixed(1)}% today)`,
                copy: getRandomCopy('bigMovers'),
                meta: `${formatVolume(mover.volume || 0)} staked on this market`
              };
            }
            break;

          case 'debateFuel':
            const debate = findDebateFuel();
            if (debate) {
              const prices = debate.outcomePrices || [];
              const yesPrice = parseFloat(prices[0] || 0);

              content = {
                label: 'DEBATE FUEL',
                labelClass: 'debate',
                title: getFullMarketTitle(debate),
                statPrimary: `YES ${(yesPrice * 100).toFixed(0)}%`,
                statPrimaryClass: 'positive',
                barWidth: yesPrice * 100,
                barClass: '',
                barContainerClass: 'split-bar',
                statSecondary: `NO ${((1 - yesPrice) * 100).toFixed(0)}%`,
                copy: getRandomCopy('debateFuel'),
                meta: `${formatVolume(debate.volume || 0)} staked on this market`
              };
            }
            break;

          case 'sentimentGaps':
            const gap = findSentimentGap();
            if (gap) {
              const prices = gap.outcomePrices || [];
              const marketPrice = parseFloat(prices[0] || 0);
              const crowdPrice = gap.crowdVote;
              const gapPct = ((crowdPrice - marketPrice) * 100).toFixed(0);
              const fansHigher = crowdPrice > marketPrice;

              content = {
                label: 'SENTIMENT GAP',
                labelClass: 'gap',
                title: getFullMarketTitle(gap),
                statPrimary: `Market: ${(marketPrice * 100).toFixed(0)}%`,
                statPrimaryClass: 'neutral',
                barWidth: crowdPrice * 100,
                barClass: fansHigher ? 'green' : 'red',
                barContainerClass: '',
                statSecondary: `Fans: ${(crowdPrice * 100).toFixed(0)}% (${gapPct > 0 ? '+' : ''}${gapPct}% gap)`,
                copy: getRandomCopy('sentimentGaps'),
                meta: `${formatVolume(gap.volume || 0)} staked on this market`
              };
            }
            break;

          case 'bigWins':
            const win = findBigWin();
            if (win) {
              let copy = getRandomCopy('bigWins')
                .replace('${payout}', '$' + win.payout)
                .replace('${profit}', '$' + win.profit)
                .replace('${returnPct}', win.returnPct);

              content = {
                label: 'BIG WIN',
                labelClass: 'win',
                title: win.question,
                statPrimary: `Entry: ${(win.entryPrice * 100).toFixed(0)}%`,
                statPrimaryClass: 'positive',
                barWidth: 100,
                barClass: 'green',
                barContainerClass: '',
                statSecondary: `Payout: ${(1/win.entryPrice).toFixed(2)}x`,
                copy: copy,
                meta: `$100 â†’ $${win.payout}`
              };
            }
            break;

          case 'longshotWatch':
            const longshot = findLongshotWatch();
            if (longshot) {
              const prices = longshot.outcomePrices || [];
              const currentPrice = parseFloat(prices[0] || 0);
              const change = parseFloat(longshot.oneDayPriceChange || 0);
              const potentialPayout = (1 / currentPrice).toFixed(1);

              content = {
                label: 'LONGSHOT WATCH',
                labelClass: 'longshot',
                title: getFullMarketTitle(longshot),
                statPrimary: `${(currentPrice * 100).toFixed(1)}%`,
                statPrimaryClass: 'neutral',
                barWidth: currentPrice * 100,
                barClass: 'green',
                barContainerClass: '',
                statSecondary: `+${(change * 100).toFixed(1)}% today Â· ${potentialPayout}x payout`,
                copy: getRandomCopy('longshotWatch'),
                meta: `${formatVolume(longshot.volume || 0)} staked on this market`
              };
            }
            break;

          case 'crowdFavorites':
            const favorite = findCrowdFavorite();
            if (favorite) {
              const crowdVote = favorite.crowdVote;
              const conviction = favorite.conviction;
              const crowdSaysYes = favorite.crowdSaysYes;
              const displayPct = (conviction * 100).toFixed(0);

              content = {
                label: 'CROWD FAVORITE',
                labelClass: 'favorite',
                title: getFullMarketTitle(favorite),
                statPrimary: `${displayPct}% say ${crowdSaysYes ? 'YES' : 'NO'}`,
                statPrimaryClass: 'positive',
                barWidth: conviction * 100,
                barClass: 'green',
                barContainerClass: '',
                statSecondary: `Overwhelming crowd consensus`,
                copy: getRandomCopy('crowdFavorites'),
                meta: `${formatVolume(favorite.volume || 0)} staked on this market`
              };
            }
            break;

          case 'volumeSurge':
            const surge = findVolumeSurge();
            if (surge) {
              const volume24h = parseFloat(surge.volume24hr || 0);
              const totalVolume = parseFloat(surge.volume || 0);
              const volumePct = ((volume24h / totalVolume) * 100).toFixed(0);
              const prices = surge.outcomePrices || [];
              const currentPrice = parseFloat(prices[0] || 0);

              content = {
                label: 'VOLUME SURGE',
                labelClass: 'volume',
                title: getFullMarketTitle(surge),
                statPrimary: `${formatVolume(volume24h)} in 24h`,
                statPrimaryClass: 'positive',
                barWidth: Math.min(volumePct, 100),
                barClass: 'green',
                barContainerClass: '',
                statSecondary: `${volumePct}% of total volume Â· ${(currentPrice * 100).toFixed(0)}% odds`,
                copy: getRandomCopy('volumeSurge'),
                meta: `${formatVolume(totalVolume)} total staked`
              };
            }
            break;

          case 'fadingFast':
            const fader = findFadingFast();
            if (fader) {
              const change = parseFloat(fader.oneDayPriceChange || 0);
              const prices = fader.outcomePrices || [];
              const currentPrice = parseFloat(prices[0] || 0);
              const previousPrice = currentPrice - change;

              content = {
                label: 'FADING FAST',
                labelClass: 'fading',
                title: getFullMarketTitle(fader),
                statPrimary: `${(previousPrice * 100).toFixed(1)}% â†’ ${(currentPrice * 100).toFixed(1)}%`,
                statPrimaryClass: 'negative',
                barWidthStart: Math.max(0, previousPrice * 100),
                barWidth: currentPrice * 100,
                barClass: 'red',
                barContainerClass: '',
                animateBar: true,
                statSecondary: `(${(change * 100).toFixed(1)}% today)`,
                copy: getRandomCopy('fadingFast'),
                meta: `${formatVolume(fader.volume || 0)} staked on this market`
              };
            }
            break;

          case 'mostEngaged':
            const engaged = findMostEngaged();
            if (engaged) {
              const crowdVote = engaged.crowdVote;
              const prices = engaged.outcomePrices || [];
              const marketPrice = parseFloat(prices[0] || 0);

              content = {
                label: 'MOST ENGAGED',
                labelClass: 'engaged',
                title: getFullMarketTitle(engaged),
                statPrimary: `Crowd: ${(crowdVote * 100).toFixed(0)}% YES`,
                statPrimaryClass: 'neutral',
                barWidth: crowdVote * 100,
                barClass: '',
                barContainerClass: 'split-bar',
                statSecondary: `Market: ${(marketPrice * 100).toFixed(0)}%`,
                copy: getRandomCopy('mostEngaged'),
                meta: `${formatVolume(engaged.volume || 0)} staked Â· High fan engagement`
              };
            }
            break;
        }

        // Apply content or use fallback
        if (content) {
          document.getElementById('editorialLabel').textContent = content.label;
          document.getElementById('editorialLabel').className = 'editorial-label ' + content.labelClass;
          document.getElementById('editorialTitle').textContent = content.title;
          document.getElementById('editorialStatPrimary').textContent = content.statPrimary;
          document.getElementById('editorialStatPrimary').className = 'editorial-stat-primary ' + content.statPrimaryClass;
          document.getElementById('editorialStatBar').className = 'editorial-stat-bar ' + (content.barContainerClass || '');

          const barFill = document.getElementById('editorialBarFill');
          barFill.className = 'editorial-bar-fill ' + content.barClass;

          // Animate bar for Big Movers (start at old value, animate to new)
          if (content.animateBar && content.barWidthStart !== undefined) {
            barFill.style.transition = 'none';
            barFill.style.width = content.barWidthStart + '%';
            // Force reflow to ensure the initial state is rendered
            barFill.offsetHeight;
            // Now animate to the new value
            setTimeout(() => {
              barFill.style.transition = 'width 1.5s ease-out';
              barFill.style.width = content.barWidth + '%';
            }, 100);
          } else {
            barFill.style.transition = 'width 0.5s ease';
            barFill.style.width = content.barWidth + '%';
          }

          document.getElementById('editorialStatSecondary').textContent = content.statSecondary;
          document.getElementById('editorialCopy').textContent = '"' + content.copy + '"';
          document.getElementById('editorialMeta').textContent = content.meta;
        }

        // Fade in
        card.classList.remove('fade-out');
        card.classList.add('fade-in');

        setTimeout(() => {
          card.classList.remove('fade-in');
        }, 300);
      }, 300);
    }

    // ============================================
    // UTILITIES
    // ============================================
    function generateToken() {
      return 'w_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
    }

    function formatPrice(price) {
      const num = parseFloat(price);
      return (num * 100).toFixed(1) + '%';
    }

    function formatVolume(vol) {
      const num = parseFloat(vol) || 0;
      if (num >= 1000000) return '$' + (num / 1000000).toFixed(1) + 'M';
      if (num >= 1000) return '$' + (num / 1000).toFixed(0) + 'K';
      return '$' + num.toFixed(0);
    }

    function formatChange(change) {
      const pct = (parseFloat(change) * 100).toFixed(1);
      if (pct > 0) return '+' + pct + '%';
      return pct + '%';
    }

    function getChangeClass(change) {
      const num = parseFloat(change);
      if (num > 0.001) return 'positive';
      if (num < -0.001) return 'negative';
      return 'neutral';
    }

    // Price change tracking
    function getPriceChange(marketId, currentPrice) {
      const previous = state.previousPrices[marketId];
      if (previous === undefined) return 0;
      return currentPrice - previous;
    }

    function storePrices(markets) {
      markets.forEach(market => {
        const prices = market.outcomePrices || [];
        const price = parseFloat(prices[0] || 0);
        state.previousPrices[market.id || market.slug] = price;
      });
    }

    function showUpdateBadge(message = 'PRICES UPDATED') {
      const badge = document.getElementById('liveUpdateBadge');
      badge.textContent = message;
      badge.classList.add('visible');
      setTimeout(() => badge.classList.remove('visible'), 2500);
    }

    function getChangeArrow(change, threshold = 0.005) {
      if (change > threshold) return '<span class="change-arrow up">â–²</span>';
      if (change < -threshold) return '<span class="change-arrow down">â–¼</span>';
      return '';
    }

    function isNFLMarket(market) {
      const text = (market.question || '').toLowerCase();
      return CONFIG.nflTerms.some(term => text.includes(term.toLowerCase()));
    }

    function parseMarketData(market) {
      let outcomes = market.outcomes;
      let prices = market.outcomePrices;

      if (typeof outcomes === 'string') {
        try { outcomes = JSON.parse(outcomes); } catch (e) { outcomes = []; }
      }
      if (typeof prices === 'string') {
        try { prices = JSON.parse(prices); } catch (e) { prices = []; }
      }

      return { ...market, outcomes, outcomePrices: prices };
    }

    // ============================================
    // API FUNCTIONS
    // ============================================
    async function fetchMarkets() {
      try {
        // Use our proxy to avoid CORS issues
        const response = await fetch(`${CONFIG.apiUrl}/markets`);
        if (!response.ok) throw new Error('API error');

        const data = await response.json();
        // API already filters for NFL markets, just parse and sort by volume
        const nflMarkets = data
          .map(parseMarketData)
          .sort((a, b) => (b.volume || 0) - (a.volume || 0));

        if (nflMarkets.length === 0) {
          throw new Error('No NFL markets found');
        }

        // Check for price changes before updating state
        let hasChanges = false;
        let biggestChange = 0;
        nflMarkets.forEach(market => {
          const prices = market.outcomePrices || [];
          const currentPrice = parseFloat(prices[0] || 0);
          const change = getPriceChange(market.id || market.slug, currentPrice);
          if (Math.abs(change) > 0.005) { // 0.5% threshold
            hasChanges = true;
            if (Math.abs(change) > Math.abs(biggestChange)) {
              biggestChange = change;
            }
          }
        });

        // Store current prices for next comparison
        const hadPreviousPrices = Object.keys(state.previousPrices).length > 0;
        storePrices(nflMarkets);

        // Show update badge if prices changed (but not on first load)
        if (hasChanges && hadPreviousPrices) {
          const direction = biggestChange > 0 ? 'â–²' : 'â–¼';
          showUpdateBadge(`PRICES UPDATED ${direction}`);
        }

        state.markets = nflMarkets;
        state.groupedEvents = groupMarketsByEvent(nflMarkets);
        state.usingMockData = false;
        document.getElementById('errorBadge').classList.remove('visible');
        console.log(`Loaded ${nflMarkets.length} NFL markets from Polymarket`);
        console.log(`Found ${state.groupedEvents.length} grouped events:`, state.groupedEvents.map(g => g.title));
        if (nflMarkets.length > 0) {
          console.log('Sample market:', JSON.stringify(nflMarkets[0], null, 2));
        }
        return { markets: nflMarkets, hasChanges };
      } catch (error) {
        console.warn('Using mock data:', error.message);
        state.markets = MOCK_MARKETS.map(parseMarketData);
        state.usingMockData = true;
        document.getElementById('errorBadge').classList.add('visible');
        return state.markets;
      }
    }

    async function fetchVoteStats(marketId) {
      try {
        const response = await fetch(`${CONFIG.apiUrl}/results/${marketId}/window/${state.currentToken}`);
        if (!response.ok) throw new Error('API error');
        const data = await response.json();
        state.voteStats = {
          window: data.window?.total || 0,
          total: data.allTime?.total || 0
        };
      } catch (error) {
        console.warn('Could not fetch vote stats:', error.message);
      }
    }

    async function fetchCrowdVotes() {
      try {
        const response = await fetch(`${CONFIG.apiUrl}/results`);
        if (!response.ok) throw new Error('API error');
        const data = await response.json();

        // Map vote results to market slugs
        // Results are keyed by market slug, yesPercent is 0-100
        if (data.results) {
          Object.keys(data.results).forEach(slug => {
            const result = data.results[slug];
            if (result.total >= 1) { // Only use if at least 1 vote
              // Convert yesPercent (0-100) to decimal (0-1)
              state.crowdVotes[slug] = result.yesPercent / 100;
            }
          });
          console.log(`Loaded crowd votes for ${Object.keys(state.crowdVotes).length} markets`);
        }
      } catch (error) {
        console.warn('Could not fetch crowd votes:', error.message);
      }
    }

    // ============================================
    // UI RENDERING
    // ============================================
    function renderHeroMarket() {
      if (state.markets.length === 0) return;

      // Hero cycles through top 10 markets by volume (markets already sorted by volume)
      const top10Markets = state.markets.slice(0, 10);
      const market = top10Markets[state.heroIndex % top10Markets.length];
      const heroCard = document.getElementById('heroCard');

      document.getElementById('heroQuestion').textContent = market.question;
      document.getElementById('heroVolume').textContent = formatVolume(market.volume24hr || market.volume || 0);

      const outcomesContainer = document.getElementById('heroOutcomes');
      const barClasses = ['primary', 'secondary', 'tertiary', 'quaternary'];

      // Check for price change on this market
      const prices = market.outcomePrices || [];
      const topPrice = parseFloat(prices[0] || 0);
      const priceChange = getPriceChange(market.id || market.slug, topPrice);

      // Get top 8 outcomes
      const topOutcomes = market.outcomes
        .map((name, i) => ({
          name,
          price: parseFloat(market.outcomePrices[i] || 0),
          change: market.oneDayPriceChange || 0
        }))
        .sort((a, b) => b.price - a.price)
        .slice(0, 8);

      const maxPrice = Math.max(...topOutcomes.map(o => o.price), 0.01);

      outcomesContainer.innerHTML = topOutcomes.map((outcome, i) => {
        const arrow = i === 0 ? getChangeArrow(priceChange) : '';
        const highlightClass = i === 0 && Math.abs(priceChange) > 0.005 ? 'value-changed' : '';
        return `
        <div class="outcome-row ${i === 0 && Math.abs(priceChange) > 0.005 ? (priceChange > 0 ? 'price-up' : 'price-down') : ''}">
          <span class="outcome-name">${outcome.name}</span>
          <div class="outcome-bar-container">
            <div class="outcome-bar ${barClasses[i % barClasses.length]}"
                 style="width: ${(outcome.price / maxPrice) * 100}%"></div>
          </div>
          <span class="outcome-price ${highlightClass}">${formatPrice(outcome.price)}${arrow}</span>
          <span class="outcome-change ${getChangeClass(outcome.change)}">${formatChange(outcome.change)}</span>
        </div>
      `}).join('');

      // Render sparkline based on 7-day price trend
      renderSparkline(market);

      // Update QR code
      updateQRCode(market.slug || market.id);

      // Fetch vote stats for this market
      fetchVoteStats(market.slug || market.id);

      // Apply glow effect if price changed significantly
      heroCard.classList.remove('card-glow-up', 'card-glow-down', 'data-updated');
      if (Math.abs(priceChange) > 0.005) {
        heroCard.classList.add(priceChange > 0 ? 'card-glow-up' : 'card-glow-down');
      } else {
        heroCard.classList.add('data-updated');
      }
      setTimeout(() => heroCard.classList.remove('data-updated', 'card-glow-up', 'card-glow-down'), 2000);
    }

    async function renderSparkline(market) {
      const container = document.getElementById('sparkline');
      const bars = 30;

      // Try to get real price history
      try {
        // Get the first token ID (Yes outcome)
        let tokenIds = market.clobTokenIds;
        if (typeof tokenIds === 'string') {
          tokenIds = JSON.parse(tokenIds);
        }

        if (tokenIds && tokenIds[0]) {
          const response = await fetch(`${CONFIG.apiUrl}/prices/${tokenIds[0]}?interval=1w&fidelity=360`);
          if (response.ok) {
            const data = await response.json();
            const history = data.history || [];

            if (history.length > 0) {
              // Sample history to get ~30 data points
              const step = Math.max(1, Math.floor(history.length / bars));
              const sampled = [];
              for (let i = 0; i < history.length; i += step) {
                sampled.push(history[i].p);
                if (sampled.length >= bars) break;
              }

              // Normalize prices to bar heights (20-100%)
              const minPrice = Math.min(...sampled);
              const maxPrice = Math.max(...sampled);
              const range = maxPrice - minPrice || 0.1;

              const heights = sampled.map(p => {
                const normalized = ((p - minPrice) / range) * 80 + 20;
                return Math.max(20, Math.min(100, normalized));
              });

              container.innerHTML = heights.map(h =>
                `<div class="sparkline-bar" style="height: ${h}%"></div>`
              ).join('');

              console.log(`Sparkline: ${history.length} points -> ${sampled.length} bars`);
              return;
            }
          }
        }
      } catch (error) {
        console.warn('Could not fetch price history:', error.message);
      }

      // Fallback: generate from oneWeekPriceChange
      const weekChange = parseFloat(market?.oneWeekPriceChange || 0);
      const currentPrice = parseFloat(market?.outcomePrices?.[0] || 0.5);
      const startPrice = currentPrice - weekChange;
      const priceRange = Math.abs(weekChange) + 0.1;

      const heights = [];
      for (let i = 0; i < bars; i++) {
        const progress = i / (bars - 1);
        const trendValue = startPrice + (weekChange * progress);
        const noise = (Math.random() - 0.5) * 0.03;
        const value = trendValue + noise;
        const normalized = ((value - startPrice + priceRange/2) / priceRange) * 80 + 20;
        heights.push(Math.max(20, Math.min(100, normalized)));
      }

      container.innerHTML = heights.map(h =>
        `<div class="sparkline-bar" style="height: ${h}%"></div>`
      ).join('');
    }

    function extractMarketName(question) {
      // Extract team/player name from question for cleaner display
      // "Will the Buffalo Bills win Super Bowl 2026?" -> "Buffalo Bills"
      const match = question.match(/Will (?:the )?(.+?) (?:win|be|make)/i);
      if (match) return match[1];
      return question.substring(0, 30);
    }

    function extractMarketCategory(question) {
      // Extract the category/event from question
      // "Will the Chiefs win Super Bowl 2026?" -> "Super Bowl 2026"
      // "Will Chris Godwin be the 2025-2026 NFL Comeback Player of the Year?" -> "NFL Comeback Player of the Year"

      // Pattern: "win [the] X" or "win X"
      let match = question.match(/win (?:the )?(.+?)(?:\?|$)/i);
      if (match) return match[1].trim();

      // Pattern: "be the X"
      match = question.match(/be (?:the )?(\d{4}[-â€“]\d{4} )?(.+?)(?:\?|$)/i);
      if (match) return (match[1] || '') + match[2].trim();

      // Pattern: "make [their] X"
      match = question.match(/make (?:their |the )?(.+?)(?:\?|$)/i);
      if (match) return match[1].trim();

      return question;
    }

    function groupMarketsByCategory(markets) {
      const groups = new Map();

      markets.forEach(market => {
        const category = extractMarketCategory(market.question);
        const outcome = extractMarketName(market.question);
        const prices = market.outcomePrices || [];
        const yesPrice = parseFloat(prices[0] || 0);
        const change = parseFloat(market.oneDayPriceChange || 0);

        if (!groups.has(category)) {
          groups.set(category, {
            category,
            outcomes: [],
            totalVolume: 0
          });
        }

        const group = groups.get(category);
        group.outcomes.push({
          name: outcome,
          price: yesPrice,
          change: change,
          volume: market.volume || 0,
          slug: market.slug
        });
        group.totalVolume += (market.volume || 0);
      });

      // Sort outcomes within each group by price
      groups.forEach(group => {
        group.outcomes.sort((a, b) => b.price - a.price);
      });

      // Convert to array and sort by total volume
      return Array.from(groups.values())
        .sort((a, b) => b.totalVolume - a.totalVolume);
    }

    // Group markets by Polymarket event ID (events[0].id)
    function groupMarketsByEvent(markets) {
      const groups = new Map();

      markets.forEach(market => {
        // Get event info from the market
        const event = market.events?.[0];
        if (!event?.id) return; // Skip markets without event grouping

        const eventId = event.id;
        const eventTitle = event.title || 'Unknown Event';

        // Use groupItemTitle for display name, fallback to extracting from question
        const displayName = market.groupItemTitle || extractMarketName(market.question);

        const prices = market.outcomePrices || [];
        const yesPrice = parseFloat(prices[0] || 0);
        const change = parseFloat(market.oneDayPriceChange || 0);

        if (!groups.has(eventId)) {
          groups.set(eventId, {
            eventId,
            title: eventTitle.trim(),
            outcomes: [],
            totalVolume: parseFloat(event.volume) || 0,
            liquidity: parseFloat(event.liquidity) || 0
          });
        }

        const group = groups.get(eventId);
        group.outcomes.push({
          name: displayName,
          price: yesPrice,
          change: change,
          volume: market.volume || 0,
          slug: market.slug,
          marketId: market.id
        });
      });

      // Sort outcomes within each group by price (highest probability first)
      groups.forEach(group => {
        group.outcomes.sort((a, b) => b.price - a.price);
      });

      // Convert to array and sort by total volume
      return Array.from(groups.values())
        .filter(g => g.outcomes.length > 1) // Only show groups with multiple outcomes
        .sort((a, b) => b.totalVolume - a.totalVolume);
    }

    function renderMovers() {
      if (state.markets.length === 0) return;

      // Get one entry per market, using actual price change (not both sides)
      const movers = state.markets
        .map(market => {
          const change = parseFloat(market.oneDayPriceChange || 0);
          const prices = market.outcomePrices || [];
          const yesPrice = parseFloat(prices[0] || 0);
          return {
            id: market.slug || market.id,
            name: extractMarketName(market.question),
            market: market.question,
            price: yesPrice,
            change: change
          };
        })
        .filter(m => Math.abs(m.change) > 0.001)
        .sort((a, b) => Math.abs(b.change) - Math.abs(a.change))
        .slice(0, 5);

      // If no real movers, show top markets by volume
      const displayMovers = movers.length > 0 ? movers : state.markets.slice(0, 5).map(m => ({
        id: m.slug || m.id,
        name: extractMarketName(m.question),
        market: m.question,
        price: parseFloat(m.outcomePrices?.[0] || 0),
        change: parseFloat(m.oneDayPriceChange || 0)
      }));

      const container = document.getElementById('moversList');
      const existingItems = container.querySelectorAll('.mover-item');

      // FLIP Animation: Record old positions
      const oldPositions = {};
      existingItems.forEach(item => {
        const id = item.dataset.id;
        if (id) {
          oldPositions[id] = item.getBoundingClientRect();
        }
      });

      // Build new position map
      const newPositionMap = {};
      displayMovers.forEach((mover, i) => {
        newPositionMap[mover.id] = i;
      });

      // Determine which items moved up or down
      const oldPositionMap = {};
      existingItems.forEach((item, i) => {
        const id = item.dataset.id;
        if (id) oldPositionMap[id] = i;
      });

      // Update DOM
      container.innerHTML = displayMovers.map((mover, i) => {
        const oldIdx = oldPositionMap[mover.id];
        let moveClass = '';
        if (oldIdx !== undefined && oldIdx !== i) {
          moveClass = oldIdx > i ? 'moving-up' : 'moving-down';
        }
        return `
          <div class="mover-item ${moveClass}" data-id="${mover.id}">
            <span class="mover-rank">${i + 1}</span>
            <div class="mover-info">
              <div class="mover-market">${mover.market}</div>
            </div>
            <span class="mover-change ${getChangeClass(mover.change)}">${formatChange(mover.change)}</span>
          </div>
        `;
      }).join('');

      // FLIP Animation: Animate from old to new positions
      const newItems = container.querySelectorAll('.mover-item');
      newItems.forEach(item => {
        const id = item.dataset.id;
        if (oldPositions[id]) {
          const oldRect = oldPositions[id];
          const newRect = item.getBoundingClientRect();
          const deltaY = oldRect.top - newRect.top;

          if (Math.abs(deltaY) > 5) {
            // Apply inverse transform
            item.style.transform = `translateY(${deltaY}px)`;
            item.style.transition = 'none';

            // Force reflow
            item.offsetHeight;

            // Animate to final position
            item.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
            item.style.transform = 'translateY(0)';
          }
        }
      });

      // Clean up animation classes after animation completes
      setTimeout(() => {
        newItems.forEach(item => {
          item.classList.remove('moving-up', 'moving-down');
        });
      }, 600);
    }

    function renderTicker() {
      console.log('renderTicker called, markets:', state.markets.length, 'grouped:', state.groupedEvents.length);

      // Use grouped events if available
      if (state.groupedEvents.length > 0) {
        const tickerItems = state.groupedEvents.map(group => {
          // Get top 3 outcomes for each group
          const topOutcomes = group.outcomes.slice(0, 3)
            .map(o => `${o.name} ${formatPrice(o.price)}`)
            .join(' Â· ');
          return {
            title: group.title,
            outcomes: topOutcomes
          };
        });

        const itemsHtml = tickerItems.map(item => `
          <div class="ticker-item">
            <span class="ticker-name ticker-event-title">${item.title}:</span>
            <span class="ticker-outcomes">${item.outcomes}</span>
          </div>
          <span class="ticker-divider">|</span>
        `).join('');

        document.getElementById('tickerContent').innerHTML = itemsHtml + itemsHtml;
        console.log('Ticker rendered with grouped events');
        return;
      }

      // Fallback: show individual markets
      if (state.markets.length === 0) {
        console.log('No markets for ticker');
        return;
      }

      const tickerItems = state.markets.map(market => {
        const prices = market.outcomePrices || [];
        return {
          name: market.question,
          price: formatPrice(prices[0] || 0),
          change: market.oneDayPriceChange || 0
        };
      });

      const itemsHtml = tickerItems.map(item => `
        <div class="ticker-item">
          <span class="ticker-name">${item.name}</span>
          <span class="ticker-price">${item.price}</span>
          <span class="ticker-change ${getChangeClass(item.change)}">${formatChange(item.change)}</span>
        </div>
        <span class="ticker-divider">|</span>
      `).join('');

      document.getElementById('tickerContent').innerHTML = itemsHtml + itemsHtml;
      console.log('Ticker rendered');
    }

    function updateQRCode(marketSlug) {
      const container = document.getElementById('qrcode');
      container.innerHTML = '';

      const voteUrl = `${CONFIG.voteAppUrl}/${marketSlug}?t=${state.currentToken}`;
      console.log('Generating QR for:', voteUrl);

      try {
        // Use qrcode-generator library
        const qr = qrcode(0, 'M'); // 0 = auto type, M = medium error correction
        qr.addData(voteUrl);
        qr.make();

        // Create image from QR code
        const img = document.createElement('img');
        img.src = qr.createDataURL(4, 0); // cell size 4, margin 0
        img.style.width = '160px';
        img.style.height = '160px';
        container.appendChild(img);
        console.log('QR code generated successfully');
      } catch (error) {
        console.error('QR generation error:', error);
        container.innerHTML = '<div style="color: #666; font-size: 12px;">QR Error: ' + error.message + '</div>';
      }
    }

    function updateCountdown() {
      const now = new Date();
      const diff = CONFIG.superBowlDate - now;

      if (diff <= 0) {
        document.getElementById('countdown').textContent = 'GAME DAY!';
        return;
      }

      const days = Math.floor(diff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

      document.getElementById('countdown').textContent = `${days}D ${hours}H ${minutes}M`;
    }

    async function updateVoteStats() {
      // Fetch total votes across ALL markets
      try {
        const response = await fetch(`${CONFIG.apiUrl}/results`);
        if (response.ok) {
          const data = await response.json();
          state.voteStats.total = data.totalVotes || 0;
        }
      } catch (error) {
        console.warn('Could not fetch vote stats:', error.message);
      }
      // Update display
      document.getElementById('totalVotes').textContent = state.voteStats.total;
    }

    function renderSecondaryMarkets() {
      const container = document.getElementById('secondaryMarkets');

      // If we have grouped events, show 3 at a time (rotating)
      if (state.groupedEvents.length > 0) {
        // Get 3 groups starting from current index, cycling through all
        const displayGroups = [];
        for (let i = 0; i < 3; i++) {
          const idx = (state.groupIndex + i) % state.groupedEvents.length;
          displayGroups.push(state.groupedEvents[idx]);
        }
        const topGroups = displayGroups;

        container.innerHTML = topGroups.map(group => {
          // Show top 4 contenders for each group
          const topOutcomes = group.outcomes.slice(0, 4);

          // Check if any outcome in this group has changed
          let groupChange = 0;
          topOutcomes.forEach(o => {
            const change = getPriceChange(o.marketId || o.slug, o.price);
            if (Math.abs(change) > Math.abs(groupChange)) groupChange = change;
          });

          const cardGlowClass = Math.abs(groupChange) > 0.005
            ? (groupChange > 0 ? 'card-glow-up' : 'card-glow-down')
            : '';

          return `
            <div class="secondary-market-card grouped ${cardGlowClass}">
              <div class="secondary-market-category">${group.title}</div>
              <div class="secondary-market-outcomes">
                ${topOutcomes.map((outcome, idx) => {
                  const priceChange = getPriceChange(outcome.marketId || outcome.slug, outcome.price);
                  const arrow = getChangeArrow(priceChange);
                  const highlightClass = Math.abs(priceChange) > 0.005 ? 'value-changed' : '';
                  const rowFlashClass = Math.abs(priceChange) > 0.005
                    ? (priceChange > 0 ? 'price-up' : 'price-down')
                    : '';
                  return `
                  <div class="outcome-row-mini ${rowFlashClass}">
                    <span class="outcome-name-mini">${idx + 1}. ${outcome.name}</span>
                    <span class="outcome-price-mini ${highlightClass}">${formatPrice(outcome.price)}${arrow}</span>
                  </div>
                `}).join('')}
              </div>
              <div class="secondary-market-volume">${formatVolume(group.totalVolume)} staked</div>
            </div>
          `;
        }).join('');
        return;
      }

      // Fallback: show individual markets if no grouped events
      if (state.markets.length < 2) return;

      const secondaryMarkets = [];
      for (let i = 1; i <= 6; i++) {
        const idx = (state.heroIndex + i) % state.markets.length;
        if (idx !== state.heroIndex % state.markets.length) {
          secondaryMarkets.push(state.markets[idx]);
        }
      }

      container.innerHTML = secondaryMarkets.map(market => {
        const prices = market.outcomePrices || [];
        const yesPrice = parseFloat(prices[0] || 0);
        const change = parseFloat(market.oneDayPriceChange || 0);
        const volume = market.volume || 0;
        const priceChange = getPriceChange(market.id || market.slug, yesPrice);
        const arrow = getChangeArrow(priceChange);
        const cardGlowClass = Math.abs(priceChange) > 0.005
          ? (priceChange > 0 ? 'card-glow-up' : 'card-glow-down')
          : '';
        const highlightClass = Math.abs(priceChange) > 0.005 ? 'value-changed' : '';

        return `
          <div class="secondary-market-card ${cardGlowClass}">
            <div class="secondary-market-question">${market.question}</div>
            <div class="secondary-market-price">
              <span class="secondary-market-value ${highlightClass}">${formatPrice(yesPrice)}${arrow}</span>
              <span class="secondary-market-change ${getChangeClass(change)}">${formatChange(change)}</span>
            </div>
            <div class="secondary-market-volume">${formatVolume(volume)} staked</div>
          </div>
        `;
      }).join('');
    }

    // ============================================
    // MAIN LOOPS
    // ============================================
    async function initialize() {
      console.log('NFL Market Pulse initializing...');

      // Initial data fetch
      await fetchMarkets();
      await fetchCrowdVotes();
      console.log('Markets loaded:', state.markets.length);

      // Initial render with error handling
      try { renderHeroMarket(); console.log('Hero rendered'); } catch(e) { console.error('Hero error:', e); }
      try { renderSecondaryMarkets(); console.log('Secondary markets rendered'); } catch(e) { console.error('Secondary error:', e); }
      try { renderMovers(); console.log('Movers rendered'); } catch(e) { console.error('Movers error:', e); }
      try { renderTicker(); console.log('Ticker rendered'); } catch(e) { console.error('Ticker error:', e); }
      try { renderEditorial(); console.log('Editorial rendered'); } catch(e) { console.error('Editorial error:', e); }
      try { updateCountdown(); } catch(e) { console.error('Countdown error:', e); }

      // Update loops
      setInterval(updateCountdown, 60000);
      setInterval(updateVoteStats, 5000);

      // Hero rotation (cycles through hero markets)
      setInterval(() => {
        state.heroIndex++;
        renderHeroMarket();
      }, CONFIG.heroRotationInterval * 1000);

      // Secondary markets rotation (cycles through all grouped events, 3 at a time)
      setInterval(() => {
        if (state.groupedEvents.length > 3) {
          state.groupIndex = (state.groupIndex + 3) % state.groupedEvents.length;
          renderSecondaryMarkets();
        }
      }, 15000); // Rotate every 15 seconds

      // Editorial rotation (cycles through themes)
      setInterval(() => {
        state.editorialIndex++;
        renderEditorial();
      }, 10000); // Rotate every 10 seconds

      // Data refresh
      setInterval(async () => {
        await fetchMarkets();
        await fetchCrowdVotes();
        renderHeroMarket();
        renderSecondaryMarkets();
        renderMovers();
        renderTicker();
      }, CONFIG.dataRefreshInterval * 1000);

      console.log('NFL Market Pulse ready!');
    }

    // Start the app
    document.addEventListener('DOMContentLoaded', initialize);
  </script>
</body>
</html>
